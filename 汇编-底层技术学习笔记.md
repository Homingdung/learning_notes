# 汇编-底层技术学习笔记

# 语言

沟通？计算机！学习计算机语言

**什么是机器语言？**

```shell
# 我们目前主流的电子计算机
0 和 1 状态
# 最早程序员，穿孔卡带！
加
减
乘
除

```

这些复杂的机器语言，如何简化？助记符！INC DEC MUL DIV-汇编语言！

编译器把人能理解的语言转换成机器能够理解的语言！

```shell
加 INC -编译器->0100 0000
减 DEC
乘 MUL
除 DIV

```

汇编一般用于底层的编写，单片机

C语言

```shell
加 A+B INC -编译器->0100 0000
减 A-B DEC
乘 A*B MUL
除 A/B DIV
```

# 进制

二进制 0 1

人类天然选择了十进制，十个指头。跳出固有思维的方法

思想：每一种进制都是完美的，都有自己的计算方式！



**进制**

1进制：逢一进一，结绳记事 

2进制：二进一，计算机 

8进制：八进一，8个符号组成 0 1 2 3 4 5 5 6 7 

10进制：十进一，10个符号组成 0 1 2 3 4 5 6 7 8 9

16进制：16进一，16个符号组成 0 1 2 3 4 5 6 7 8 9 a b c d e f

学会**查数**

```shell
# 一进制 1-20
1
1 1
1 1 1
# 二进制
0 10 11 100 101 110 111 1000
# 七进制
0 1 2 3 4 5 6 
10 11 12 13 14 15 16
20 21 22 23 24 25 26
```

进制可以定义；
加密解密：**进制的加密！**

数字量一大，总是有规律的！

# 进制运算

```shell
# 八进制计算下面的结果
2+3=5 (2 往后数三位)
2*3=6
4+5=11
4*5=24

# 运算的本质就是查数
0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27

# 八进制计算下面结果 九九乘法表=加法表！减法的本质是加法！除法的本质是乘法！
277+333=
276*54=
237-54=

```

无论什么进制，本身有一套完美的运算体系，我们都可以通过列表的方式将它计算出来！

# 二进制

计算机使用二进制 0 1！状态！电子！

物理极限：摩尔定律！-硬操作

追求语言的极限：并发语言！-软操作

**量子计算机**：

可以使用量子计算的机器

传统的计算机：集成电路！0 1 硅晶片

量子计算机的单位：昆比特。（量子比特！）量子的两态来表示

光子：正交偏振方向

磁场：电子的自旋方向

21世纪：计算力，快到尽头了！【落伍】--本质问题

量子计算机：提高计算机的计算力

量子比特，量子叠加态，量子纠缠，量子并行原理

电子计算机==量子计算机



电子计算机：

```shell
二进制：0 1111
0 1 10 11 100 101 110 111 1000 1001 1010 1100 1101 1111
```

二进制这么去写很麻烦！二进制能否简写！

```shell
0 1 2  3  4    5   6  7   8     9     a    b    c    d   e   f # 16进制

```

**计算机操作系统原理**-可以后续研究一下

课程上的教学：2进制转换成10进制-然后计算（不要用）



为什么要学习理解二进制

寄存器，内存，位！底层的每一个位都是有含义的--汇编入门理解的基础

汇编高级：了解程序的深层！操作系统的内核！



# 数据宽度

计算机：内存！给数据增加数据宽度

c和c++java都需要定义数据类型。计算机底层需要给数据定义宽度

位： 0 1

字节： 0-oxFF

字：0-oxFFFF

双字：0-oxFFFFFFFF

在计算机中，每一个数据都要定义类型，定义宽度

# 有符号数无符号数

数据都是有宽度的，每个数据代表什么意思呢？

```shell
0 1 0 1 0 1 0 1
```

**规则**，二进制解码增加一个规则

无符号数规则

这个数字是什么，就是什么

```shell
1 0 0 1  1 0 1 0 十六进制：0x9A 
```

有符号数规则

最高位是符号位：1（负数）0（正数）

```shell
1 0 0 1  1 0 1 0 如何转换？
```

# 原码反码补码

编码规则

**有符号数的编码规则**

原码：最高位符号位，对齐它的为进行本身绝对值即可

反码：

+ 正数：反码和原码相同
+ 负数：符号位一定是1，其余位对原码取反

补码：

+ 正数：补码和原码相同
+ 负数：符号位一定是1，反码+1

```shell
# 以下都是8位
# 如果是正数，那都是一样的
1
# 原码：0 0 0 0  0 0 0 1
# 反码：0 0 0 0  0 0 0 1
# 补码：0 0 0 0  0 0 0 1

# 如果是负数 -1
# 原码：0 0 0 0  0 0 0 1 
# 反码：1 1 1 1  1 1 1 0 # 取反
# 补码：1 1 1 1  1 1 1 1 

-7
# 原码：1 0 0 0  0 1 1 1 
# 反码：1 1 1 1  1 0 0 0
# 补码：1 1 1 1  1 0 0 1

```

寄存器：mov寄存器，值

# 位运算

计算机可以存储所有的数字（正数 浮点数 字符）

0 1

位运算

2*8最高效的计算方式

很多底层调试器，需要通过位来判断CPU的状态



**与运算**（and&）

两个都为1，结果为1

```shell
1011 0001
1101 1000
----------与运算结果
1001 0000
```

**或运算**（or｜）

``` shell
1011 0001
1101 1000
----------或运算结果
1111 1001
```

**异或运算**（xor）

不相同则为1

```shell
1011 0001
1101 1000
----------异或运算结果
0110 1001
```

**非运算**（单目运算符 not～）

0就是1，1就是0，取反

```shell
1101 1000
---------
0010 0111
```



通过这些可以完成加减乘除！！

**位运算（移动位）**

左移：（shl<<）

```shell
0000 0001 所有二进制位全部左移若干位，高位丢弃，低位补0
0000 0010
```



右移：（shr>>）

```shell
0000 0001 所有二进制位全部右移若干位，低位丢弃，高位补0，1（符号位决定）
0000 0000
```



```shell
0000 0001  1
0000 0010  2
0000 0100  4
0000 1000  8
```

二进制，位运算=>加减乘除



# 位运算的加减乘除

计算机只认识0 1 

基本数学是建立在加减乘除上面的。（加法）

4+5

```shell
# 计算机是怎么操作的
0000 0100 
0000 0101
---------(加法，计算机不会直接加的)
0000 1001

# 计算机的实现原理
# 第一步 异或：不考虑进位，异或可以直接出结果
0000 0100
0000 0101
---------
0000 0001
# 第二步，与运算（判断进位！如果与运算结果为0，没有进位）
0000 0100
0000 0101
---------
0000 0100
# 第三步，将与运算的结果，左移一位 0000 1000 #进位结果
# 第四步，异或！
0000 0001
0000 1000
---------
0000 1001
# 第五步，与运算（判断进位！如果与运算结果为0，没有进位）
0000 0001
0000 1000
---------
0000 0000 #没有进位了
# 所以最终结果就是与运算结果为0的上一个异或运算结果
```

4-5？

```shell
# 计算机怎么操作减法
4+（-5）
0000 0100
1111 1011 补码<--0000 0101--5
---------(减法法：计算机是不会直接减的)
1111 1111 ff

0000 0100
1111 1011
---------(异或)
1111 1111

0000 0100
1111 1011
---------（与-判断进位，如果与运算结果为0，没有进位）
0000 0000

最终结果1111 1111 (Hex: ff Dec:-1)
```

乘：x*y,就是y个x相加，还是加法

除：x/y，本质就是减法，就是x能减去多少个y

**计算机只会做加法！**



编译器的发展，鼓励用最底层最古老的IDE

学习汇编之前，需要掌握环境的配置，Vc6

**学汇编不是为了写代码**，是为了理解程序本质

















